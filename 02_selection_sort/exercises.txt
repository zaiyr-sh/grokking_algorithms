Упражнения

2.1 Допустим, вы строите приложение для управления финансами.
1. ПРОДУКТЫ
2. КИНО
3. ВЕЛОСИПЕДНЫЙ КЛУБ
Ежедневно вы записываете все свои траты. В конце месяца вы анали­зируете расходы и вычисляете, 
сколько денег было потрачено. При работе с данными выполняется множество операций вставки 
и отно­сительно немного операций чтения. Какую структуру использовать - массив или список?

Ответ: В данном случае траты добавляются в список ежедневно, 
а чтение всех данных происходит один раз в месяц. Для массивов характерно быстрое чтение и медленная вставка, 
а для связанных списков - медленное чтение и быстрая вставка. Так как вставка будет выполняться намного чаще, 
чем чтение, есть смысл воспользоваться связанным списком. Кроме того, чтение в связанных списках происхо­дит медленно
только при обращении к случайным элементам списка. Так как читаться будут все элементы списка, 
связанный список также неплохо справится с чтением. Итак, связанный список станет хорошим решением этой задачи.

------------------------------------------------------------------------

2.2 Допустим, вы пишете приложение для приема заказов от посетителей ресторана. 
Приложение должно хранить список заказов. Официанты добавляют заказы в список, а повара читают заказы из списка 
и вы­полняют их. Заказы образуют очередь: официанты добавляют заказы в конец очереди, а повар берет первый заказ 
из очереди и начинает готовить.

Ответ: Связанный список. Вставка происходит очень часто (офици­анты добавляют заказы), а связанные списки эффективно 
выполняют эту операцию. Ни поиск, ни произвольный доступ (сильные стороны массивов) вам не понадобятся, 
потому что повар всегда извлекает из очереди первый заказ.

------------------------------------------------------------------------

2.3 Проведем мысленный эксперимент. Допустим, Facebook хранит список имен пользователей. Когда кто-то пытается зайти 
на сайт Facebook, система пытается найти имя пользователя. Если имя входит в список имен зарегистрированных 
пользователей, то вход разреша­ется. Пользователи приходят на Facebook достаточно часто, поэтому поиск по списку 
имен пользователей будет выполняться часто. Будем считать, что Facebook использует бинарный поиск для поиска в спи­ске.
Бинарному поиску необходим произвольный доступ - алгоритм должен мгновенно обратиться к среднему элементу текущей 
части списка. Зная это обстоятельство, как бы вы реализовали список поль­зователей: в виде массива или в виде 
связанного списка?

Ответ: В виде отсортированного массива. Массивы обеспечивают произвольный доступ - вы можете мгновенно получить 
элемент из середины массива. Со связанными списками это невозможно. Чтобы получить элемент из середины связанного 
списка, вам придется начать с первого элемента и переходить по ссылкам до нужного элемента.

------------------------------------------------------------------------

2.4 Пользователи также довольно часто создают новые учетные записи на Facebook. Предположим, вы решили использовать 
массив для хране­ния списка пользователей. Какими недостатками обладает массив для выполнения вставки? Допустим, 
вы используете бинарный поиск для нахождения учетных данных. Что произойдет при добавлении новых пользователей 
в массив?

Ответ: Вставка в массив выполняется медленно. Кроме того, если вы используете бинарный поиск для нахождения имен 
пользователей, массив необходимо отсортировать. Предположим, пользователь по имени Adit В регистрируется на Facebook. 
Его имя будет вставлено в конец массива. Следовательно, массив нужно будет сортировать при каждой вставке нового имени!

------------------------------------------------------------------------

2.5 В действительности Facebook не использует ни массив, ни связанный список для хранения информации о пользователях. 
Рассмотрим ги­бридную структуру данных: массив связанных списков. Имеется мас­сив из 26 элементов. 
Каждый элемент содержит ссылку на связанный список. Например, первый элемент массива указывает на связанный список 
всех имен пользователей, начинающихся на букву «А». Второй элемент указывает на связанный список всех имен 
пользователей, на­чинающихся на букву «В», и т.д.
Предположим, пользователь с именем «Adit B» регистрируется на Facebook и вы хотите добавить его в список. 
Вы обращаетесь к эле­менту 1 массива, находите связанный список элемента 1 и добавляете «Adit B» в конец списка. 
Теперь предположим, что зарегистрировать нужно пользователя «Zakhir H». Вы обращаетесь к элементу 26, ко­торый 
содержит связанный список всех имен, начинающихся с «Z», и проверяете, присутствует ли «Zakhir H» в этом списке.
Теперь сравните эту гибридную структуру данных с массивами и свя­занными списками. Будет ли она быстрее или медленнее
каждой ис­ходной структуры при поиске и вставке? Приводить время выполнения «О-большое» не нужно, просто выберите 
одно из двух: быстрее или медленнее.

Ответ: Поиск - медленнее, чем для массивов, и быстрее, чем для связанных списков. Вставка - быстрее, чем для массивов, 
и с такой же скоростью для связанных списков. Итак, гибридная структура уступа­ет массиву по скорости поиска, 
но по крайней мере не хуже связанных списков для всего остального. Далее в книге будет рассмотрена другая гибридная 
структура данных, называемая хеш-таблицей. Она даст не­которое представление о том, как строить сложные структуры 
данных из более простых. Что же в действительности использует сервис Facebook? Вероятно, десяток разных баз данных, 
за которыми стоят разные структуры данных: хеш-таблицы, в-деревья и т. д. Массивы и связанные списки становятся 
структурными элементами для построения более сложных структур данных.